# ğŸ“¸ ShutterLink

ì‚¬ì§„ í•„í„° ì°½ì‘ìì™€ êµ¬ë§¤ìë¥¼ ì—°ê²°í•´ì£¼ê³  í•„í„°ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì ìš©í•´ ë³¼ ìˆ˜ ìˆëŠ” ì•±ì…ë‹ˆë‹¤.

<div align="center">
    
| ì•± ìŠ¤í¬ë¦°ìƒ· |
|:---:|
| ![ì•± ìŠ¤í¬ë¦°ìƒ· ì˜ˆì‹œ](ë§í¬) | 

</div>

## ğŸ“‹ ëª©ì°¨

- í”„ë¡œì íŠ¸ ì†Œê°œ
- ì£¼ìš”ê¸°ëŠ¥
- ê¸°ìˆ  ìŠ¤íƒ
- í”„ë¡œì íŠ¸ êµ¬ì¡°
- ì£¼ìš” êµ¬í˜„ ë‚´ìš©
- íŠ¸ëŸ¬ë¸” ìŠˆíŒ…

  
## ğŸ—“ï¸ ê°œë°œ ì •ë³´
- **ì§‘ì¤‘ê°œë°œ ê¸°ê°„**: 2025.05.09 ~ 2025.06.20 (ì•½ 6ì£¼)
- **ê°œë°œ ì¸ì›**: 1ëª…
- **ë‹´ë‹¹ ì—…ë¬´**: ê¸°íš, ë””ìì¸, ê°œë°œ, í…ŒìŠ¤íŠ¸

## ğŸ’ğŸ»â€â™‚ï¸ í”„ë¡œì íŠ¸ ì†Œê°œ

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ShutterLinkëŠ” ì‚¬ì§„ í•„í„° ì°½ì‘ìì™€ ì‚¬ìš©ìë¥¼ ì—°ê²°í•˜ëŠ” ë§ˆì¼“í”Œë ˆì´ìŠ¤ ì•±ì…ë‹ˆë‹¤    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ì°½ì‘ìëŠ” ì§ê´€ì ì¸ ë„êµ¬ë¡œ í•„í„°ë¥¼ ì œì‘í•˜ê³  íŒë§¤í•  ìˆ˜ ìˆìœ¼ë©°,    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ì‚¬ìš©ìëŠ” ë‹¤ì–‘í•œ ê³ í’ˆì§ˆ í•„í„°ì˜ í•„í„° ê°’ì„ êµ¬ë§¤í•˜ì—¬ ìì‹ ì˜ ì‚¬ì§„ì— ì‹¤ì‹œê°„ìœ¼ë¡œ ì ìš©í•´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ì‹¤ì‹œê°„ ì±„íŒ…ì„ í†µí•´ ì°½ì‘ìì™€ ì§ì ‘ ì†Œí†µí•˜ê³ ,    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ì•ˆì „í•œ ê²°ì œ ì‹œìŠ¤í…œìœ¼ë¡œ ê°„ë‹¨í•˜ì§€ë§Œ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ê±°ë˜ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.   


## â­ï¸ ì£¼ìš” ê¸°ëŠ¥

- **ì‹¤ì‹œê°„ ì±„íŒ…**: ì°½ì‘ìì™€ 1:1 ì†Œí†µ ë° ë¬¸ì˜
- **í•„í„° ë§ˆì¼“í”Œë ˆì´ìŠ¤**: ë‹¤ì–‘í•œ í•„í„° íƒìƒ‰ ë° ì¹´í…Œê³ ë¦¬ë³„ ê²€ìƒ‰
- **í•„í„° ì œì‘ ë„êµ¬**: Core Image ê¸°ë°˜ ê³ ì„±ëŠ¥ ì´ë¯¸ì§€ í¸ì§‘ ì‹œìŠ¤í…œ
- **ì•ˆì „í•œ ê²°ì œ**: ì•„ì„í¬íŠ¸ ì—°ë™ PG ê²°ì œ ì‹œìŠ¤í…œ
- **í”„ë¡œí•„ ê´€ë¦¬**: ì¢‹ì•„ìš”í•œ í•„í„° ëª¨ì•„ë³´ê¸° ë° í”„ë¡œí•„ ìˆ˜ì •, ì±„íŒ… ë‚´ì—­ í™•ì¸
- **ê²€ìƒ‰ ê¸°ëŠ¥**: í•„í„°/ì°½ì‘ì í†µí•© ê²€ìƒ‰ ì‹œìŠ¤í…œ
- **ì†Œì…œ ë¡œê·¸ì¸**: ì¹´ì¹´ì˜¤í†¡, ì• í”Œ ê°„í¸ ë¡œê·¸ì¸


## ğŸ›  ê¸°ìˆ  ìŠ¤íƒ

![ê¸°ìˆ ìŠ¤íƒì´ë¯¸ì§€](ë§í¬)

- **ì–¸ì–´ ë° í”„ë ˆì„ì›Œí¬**: Swift, SwiftUI
- **ì•„í‚¤í…ì²˜**: Clean Architecture + MVVM + Input/Output íŒ¨í„´
- **UI í”„ë ˆì„ì›Œí¬**: SwiftUI
- **ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°**: Combine + async/await
- **ë„¤íŠ¸ì›Œí¬ í†µì‹ **: URLSession + Router Pattern
- **ì‹¤ì‹œê°„ í†µì‹ **: SocketIO
- **ë¡œì»¬ ë°ì´í„°ë² ì´ìŠ¤**: RealmSwift
- **ì´ë¯¸ì§€ ì²˜ë¦¬**: Core Image, PhotosUI
- **ê²°ì œ ì‹œìŠ¤í…œ**: ì•„ì„í¬íŠ¸(IMP)
- **ì§€ë„ ì„œë¹„ìŠ¤**: MapKit
- **ì¸ì¦**: JWT Token + OAuth (ì¹´ì¹´ì˜¤, ì• í”Œ)

## í”„ë¡œì íŠ¸ êµ¬ì¡°

```
ShutterLink/
â”œâ”€â”€ Presentation/
â”‚   â”œâ”€â”€ 01_Home/
â”‚   â”‚   â”œâ”€â”€ HomeView.swift
â”‚   â”‚   â”œâ”€â”€ HomeViewModel.swift
â”‚   â”‚   â”œâ”€â”€ TodayAuthor/
â”‚   â”‚   â””â”€â”€ HotTrend/
â”‚   â”œâ”€â”€ 02_1_FilterDetail/
â”‚   â”‚   â”œâ”€â”€ FilterDetailView.swift
â”‚   â”‚   â”œâ”€â”€ FilterDetailViewModel.swift
â”‚   â”‚   â””â”€â”€ Components/
â”‚   â”œâ”€â”€ 03_MakeFilter/
â”‚   â”‚   â”œâ”€â”€ MakeView.swift
â”‚   â”‚   â”œâ”€â”€ MakeEditView.swift
â”‚   â”‚   â”œâ”€â”€ MakeViewModel.swift
â”‚   â”‚   â””â”€â”€ Core/
â”‚   â”œâ”€â”€ 04_Search/
â”‚   â”‚   â”œâ”€â”€ SearchView.swift
â”‚   â”‚   â”œâ”€â”€ SearchViewModel.swift
â”‚   â”‚   â””â”€â”€ 04_UserDetail/
â”‚   â”œâ”€â”€ 05_Profile/
â”‚   â”‚   â”œâ”€â”€ ProfileView.swift
â”‚   â”‚   â”œâ”€â”€ ProfileViewModel.swift
â”‚   â”‚   â””â”€â”€ ProfileEditView.swift
â”‚   â”œâ”€â”€ Chat/
â”‚   â”‚   â”œâ”€â”€ ChatRoomListView.swift
â”‚   â”‚   â”œâ”€â”€ ChatView/
â”‚   â”‚   â””â”€â”€ ChatViewModel.swift
â”‚   â”œâ”€â”€ SignIn/
â”‚   â”‚   â”œâ”€â”€ SignInView.swift
â”‚   â”‚   â””â”€â”€ SignInViewModel.swift
â”‚   â””â”€â”€ SignUp/
â”‚       â”œâ”€â”€ SignUpView.swift
â”‚       â””â”€â”€ SignUpViewModel.swift
â”œâ”€â”€ Domain/
â”‚   â””â”€â”€ UseCase/
â”‚       â”œâ”€â”€ AuthUseCase.swift
â”‚       â”œâ”€â”€ FilterUseCase.swift
â”‚       â”œâ”€â”€ ChatUseCase.swift
â”‚       â”œâ”€â”€ OrderUseCase.swift
â”‚       â”œâ”€â”€ ProfileUseCase.swift
â”‚       â”œâ”€â”€ UserUseCase.swift
â”‚       â””â”€â”€ SocketUseCase.swift
â”œâ”€â”€ Model/
â”‚   â”œâ”€â”€ Network/
â”‚   â”‚   â”œâ”€â”€ Manager/
â”‚   â”‚   â”‚   â”œâ”€â”€ SignIn/
â”‚   â”‚   â”‚   â”œâ”€â”€ Token/
â”‚   â”‚   â”‚   â”œâ”€â”€ Chat/
â”‚   â”‚   â”‚   â””â”€â”€ Payments/
â”‚   â”‚   â”œâ”€â”€ DTOs/
â”‚   â”‚   â”‚   â”œâ”€â”€ Auth.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ Filter.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ FilterDetail.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ Chat.swift
â”‚   â”‚   â”‚   â””â”€â”€ UserSearch.swift
â”‚   â”‚   â””â”€â”€ Router/
â”‚   â”‚       â”œâ”€â”€ AuthRouter.swift
â”‚   â”‚       â”œâ”€â”€ FilterRouter.swift
â”‚   â”‚       â”œâ”€â”€ ChatRouter.swift
â”‚   â”‚       â””â”€â”€ OrderRouter.swift
â”‚   â”œâ”€â”€ Chat/
â”‚   â”‚   â”œâ”€â”€ Entity/
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatRoomEntity.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatMessageEntity.swift
â”‚   â”‚   â”‚   â””â”€â”€ UserEntity.swift
â”‚   â”‚   â””â”€â”€ Repository/
â”‚   â”‚       â””â”€â”€ ChatLocalRepository.swift
â”‚   â””â”€â”€ Payments/
â”‚       â”œâ”€â”€ OrderModels.swift
â”‚       â””â”€â”€ PaymentModels.swift
â”œâ”€â”€ Component/
â”‚   â”œâ”€â”€ Navigation/
â”‚   â”‚   â”œâ”€â”€ NavigationRouter.swift
â”‚   â”‚   â””â”€â”€ NavigationRoutes.swift
â”‚   â””â”€â”€ Common/
â”‚       â”œâ”€â”€ CustomButton.swift
â”‚       â””â”€â”€ LoadingView.swift
â”œâ”€â”€ Utility/
â”‚   â”œâ”€â”€ ImageLoader.swift
â”‚   â”œâ”€â”€ NavigationLazyView.swift
â”‚   â””â”€â”€ Extensions/
â”‚       â”œâ”€â”€ Font+Extension.swift
â”‚       â””â”€â”€ Color+Extension.swift
â””â”€â”€ Resources/
    â”œâ”€â”€ Design/
    â”‚   â”œâ”€â”€ DesignSystem.swift
    â”‚   â”œâ”€â”€ Colors.swift
    â”‚   â””â”€â”€ Typography.swift
    â””â”€â”€ Assets.xcassets
```

## ğŸ’¡ ì£¼ìš” êµ¬í˜„ ë‚´ìš©

### **Clean Architecture ê¸°ë°˜ í™•ì¥ ê°€ëŠ¥í•œ ì•± ì•„í‚¤í…ì²˜ ì„¤ê³„**
* Domain, Presentation, Data ë ˆì´ì–´ë¥¼ ëª…í™•íˆ ë¶„ë¦¬í•˜ì—¬ ë‹¨ì¼ ì±…ì„ ì›ì¹™ê³¼ ì˜ì¡´ì„± ì—­ì „ ì›ì¹™ ì¤€ìˆ˜
* UseCase íŒ¨í„´ìœ¼ë¡œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ìº¡ìŠí™”í•˜ê³  Repository Patternìœ¼ë¡œ ë°ì´í„° ì ‘ê·¼ ì¶”ìƒí™”
* í”„ë¡œí† ì½œ ê¸°ë°˜ ì˜ì¡´ì„± ì£¼ì…ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ìš©ì´ì„± í™•ë³´ ë° ëª¨ë“ˆ ê°„ ê²°í•©ë„ ìµœì†Œí™”
* ê³„ì¸µë³„ ì—­í•  ë¶„ë¦¬ë¡œ ìœ ì§€ë³´ìˆ˜ì„±ê³¼ í™•ì¥ì„± í–¥ìƒ

```swift
// Domain Layer - UseCase íŒ¨í„´
protocol FilterUseCase {
    func getFilterDetail(filterId: String) async throws -> FilterDetailResponse
    func likeFilter(filterId: String, likeStatus: Bool) async throws -> Bool
    func uploadFilterFiles(originalData: Data, filteredData: Data) async throws -> [String]
}

final class FilterUseCaseImpl: FilterUseCase {
    private let networkManager = NetworkManager.shared
    
    func getFilterDetail(filterId: String) async throws -> FilterDetailResponse {
        let router = FilterRouter.getFilterDetail(filterId: filterId)
        return try await networkManager.request(router, type: FilterDetailResponse.self)
    }
}
```

### **SwiftUIì™€ Combineì„ í™œìš©í•œ ë°˜ì‘í˜• MVVM ì•„í‚¤í…ì²˜ êµ¬í˜„**
* Input/Output íŒ¨í„´ìœ¼ë¡œ ë‹¨ë°©í–¥ ë°ì´í„° í”Œë¡œìš° êµ¬ì¶•í•˜ì—¬ ìƒíƒœ ê´€ë¦¬ ë³µì¡ë„ ê°ì†Œ
* @Published í”„ë¡œí¼í‹°ì™€ PassthroughSubject ì¡°í•©ìœ¼ë¡œ UI ìƒíƒœ ë³€ê²½ ìë™ ë°˜ì˜
* Driver íŒ¨í„´ ì ìš©ìœ¼ë¡œ ë©”ì¸ ìŠ¤ë ˆë“œ ë³´ì¥ ë° ì—ëŸ¬ ì „íŒŒ ì°¨ë‹¨
* Combineì˜ ì·¨ì†Œ ë©”ì»¤ë‹ˆì¦˜ í™œìš©ìœ¼ë¡œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ ë° ìƒëª…ì£¼ê¸° ê´€ë¦¬

```swift
class FilterDetailViewModel: ObservableObject {
    struct Input {
        let loadFilterDetail = PassthroughSubject<String, Never>()
        let purchaseFilter = PassthroughSubject<String, Never>()
        let likeFilter = PassthroughSubject<(String, Bool), Never>()
    }
    
    struct Output {
        let filterDetail: AnyPublisher<FilterDetailResponse?, Never>
        let isPurchasing: AnyPublisher<Bool, Never>
        let likeStatus: AnyPublisher<Bool, Never>
    }
    
    @Published var filterDetail: FilterDetailResponse?
    @Published var isPurchasing = false
    
    private let input = Input()
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        transform()
    }
    
    private func transform() {
        input.loadFilterDetail
            .flatMap { [weak self] filterId -> AnyPublisher<FilterDetailResponse, Never> in
                guard let self = self else { return Empty().eraseToAnyPublisher() }
                return self.filterUseCase.getFilterDetail(filterId: filterId)
                    .catch { _ in Empty() }
                    .eraseToAnyPublisher()
            }
            .assign(to: \.filterDetail, on: self)
            .store(in: &cancellables)
    }
}
```

### **Router Pattern ê¸°ë°˜ íƒ€ì… ì„¸ì´í”„í•œ ë„¤íŠ¸ì›Œí¬ ê³„ì¸µ ëª¨ë“ˆí™”**
* URLRequestConvertible í”„ë¡œí† ì½œ êµ¬í˜„ìœ¼ë¡œ API ì—”ë“œí¬ì¸íŠ¸ë¥¼ íƒ€ì… ì„¸ì´í”„í•˜ê²Œ ê´€ë¦¬
* Genericì„ í™œìš©í•œ ë„¤íŠ¸ì›Œí¬ ë§¤ë‹ˆì €ë¡œ ì½”ë“œ ì¤‘ë³µ ì œê±° ë° ì¬ì‚¬ìš©ì„± í–¥ìƒ
* ê³µí†µ ë„¤íŠ¸ì›Œí¬ ë¡œì§(ì¸ì¦, ì—ëŸ¬ ì²˜ë¦¬, ë¡œê¹…) ì¤‘ì•™í™”ë¡œ ìœ ì§€ë³´ìˆ˜ì„± ê°œì„ 
* ìœ ì§€ë³´ìˆ˜ê°€ ì‰½ê³  ë²„ê·¸ ì›ì¸ì„ íŒŒì•…í•˜ê¸° ì‰½ë„ë¡ ë¯¸ë“¤ì›¨ì–´ íŒ¨í„´ìœ¼ë¡œ ìš”ì²­/ì‘ë‹µ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ êµ¬ì„±

```swift
// Router Pattern êµ¬í˜„
enum FilterRouter: APIRouter {
    case getFilterDetail(filterId: String)
    case likeFilter(filterId: String, likeStatus: Bool)
    case uploadFilterFiles(originalData: Data, filteredData: Data)
    
    var path: String {
        switch self {
        case .getFilterDetail(let filterId):
            return "/filters/\(filterId)"
        case .likeFilter(let filterId, _):
            return "/filters/\(filterId)/like"
        case .uploadFilterFiles:
            return "/filters/files"
        }
    }
    
    var method: HTTPMethod {
        switch self {
        case .getFilterDetail:
            return .GET
        case .likeFilter, .uploadFilterFiles:
            return .POST
        }
    }
}

// Generic Network Manager
class NetworkManager {
    func request<T: Decodable>(_ router: APIRouter, type: T.Type) async throws -> T {
        let request = try router.asURLRequest()
        let (data, response) = try await URLSession.shared.data(for: request)
        
        // ì‘ë‹µ ê²€ì¦ ë° ë””ì½”ë”©
        try validateResponse(response)
        return try JSONDecoder().decode(T.self, from: data)
    }
}
```

### **Core Image ê¸°ë°˜ ê³ ì„±ëŠ¥ ì‹¤ì‹œê°„ ì´ë¯¸ì§€ í•„í„°ë§ ì‹œìŠ¤í…œ**
* CIFilter ì²´ì¸ì„ í™œìš©í•œ GPU ê°€ì† ë Œë”ë§ìœ¼ë¡œ ì‹¤ì‹œê°„ ì´ë¯¸ì§€ ì²˜ë¦¬ êµ¬í˜„
* í•„í„° íŒŒë¼ë¯¸í„° ì‹¤ì‹œê°„ ì¡°ì • ë° í”„ë¦¬ë·° ì‹œìŠ¤í…œìœ¼ë¡œ ì‚¬ìš©ì ê²½í—˜ í–¥ìƒ
* ì´ë¯¸ì§€ ë‹¤ìš´ìƒ˜í”Œë§ê³¼ ë¹„ë™ê¸° ì²˜ë¦¬ë¡œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”
* CIContext ì¬ì‚¬ìš©ê³¼ ìºì‹± ì „ëµìœ¼ë¡œ ë Œë”ë§ ì„±ëŠ¥ ê·¹ëŒ€í™”

```swift
class CoreImageProcessor: ObservableObject {
    private let context = CIContext()
    private var originalCIImage: CIImage?
    
    func applyFilters(with state: EditingState) -> UIImage? {
        guard let originalImage = originalCIImage else { return nil }
        var filteredImage = originalImage
        
        // ìƒ‰ìƒ ì¡°ì • í•„í„° ì ìš©
        let colorFilter = CIFilter.colorControls()
        colorFilter.inputImage = filteredImage
        colorFilter.brightness = Float(state.brightness)
        colorFilter.contrast = Float(state.contrast)
        colorFilter.saturation = Float(state.saturation)
        
        if let output = colorFilter.outputImage {
            filteredImage = output
        }
        
        // ë…¸ì¶œ ì¡°ì •
        if abs(state.exposure) > 0.1 {
            let exposureFilter = CIFilter.exposureAdjust()
            exposureFilter.inputImage = filteredImage
            exposureFilter.ev = Float(state.exposure)
            if let output = exposureFilter.outputImage {
                filteredImage = output
            }
        }
        
        // ìµœì¢… ë Œë”ë§
        guard let cgImage = context.createCGImage(filteredImage, from: filteredImage.extent) else {
            return nil
        }
        
        return UIImage(cgImage: cgImage)
    }
    
    // ë¯¸ë¦¬ë³´ê¸°ìš© ê²½ëŸ‰í™” í•„í„°ë§
    func generatePreview(with state: EditingState, targetSize: CGSize) -> UIImage? {
        guard let originalImage = originalCIImage else { return nil }
        
        // í¬ê¸° ì¡°ì •ìœ¼ë¡œ ì„±ëŠ¥ ìµœì í™”
        let scaleTransform = CGAffineTransform(
            scaleX: targetSize.width / originalImage.extent.width,
            y: targetSize.height / originalImage.extent.height
        )
        let scaledImage = originalImage.transformed(by: scaleTransform)
        
        // ì£¼ìš” í•„í„°ë§Œ ì ìš©í•˜ì—¬ ì‹¤ì‹œê°„ ì„±ëŠ¥ ë³´ì¥
        return applyMainFilters(to: scaledImage, state: state)
    }
}
```

### **JWT í† í° ê¸°ë°˜ ìë™ ë¡œê·¸ì¸ ì‹œìŠ¤í…œ êµ¬í˜„**
* ë¦¬í”„ë ˆì‹œ í† í°ì„ í™œìš©í•œ ì„¸ì…˜ ìœ ì§€ì™€ ì•± ì¬ì‹œì‘ ì‹œ ìë™ ë¡œê·¸ì¸ êµ¬í˜„
* í† í° ë§Œë£Œ 10ì´ˆ ì „ ìë™ ê°±ì‹  íƒ€ì´ë¨¸ë¡œ ëŠê¹€ ì—†ëŠ” ì‚¬ìš©ì ê²½í—˜ ì œê³µ
* ì•± ìƒëª…ì£¼ê¸°ì— ë”°ë¥¸ í† í° ìƒíƒœ ê´€ë¦¬ì™€ ë°±ê·¸ë¼ìš´ë“œ/í¬ê·¸ë¼ìš´ë“œ ì „í™˜ ì‹œ í† í° ê²€ì¦
* í† í° ê°±ì‹  ì‹¤íŒ¨ ì‹œ ìš°ì•„í•œ ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬ì™€ ìë™ ë¡œê·¸ì¸ ëª¨ë‹¬ í‘œì‹œ

```swift
class AuthState: ObservableObject {
    func loadUserIfTokenExists() async {
        guard tokenManager.refreshToken != nil else {
            await MainActor.run { self.isLoggedIn = false }
            return
        }
        
        await MainActor.run { isLoading = true }
        
        do {
            // í† í° ê°±ì‹  ì‹œë„
            try await refreshAccessToken()
            
            // í”„ë¡œí•„ ì •ë³´ë¡œ ì‚¬ìš©ì ìƒíƒœ ë³µì›
            let profileResponse = try await profileUseCase.getMyProfile()
            let user = User(
                id: profileResponse.user_id,
                email: profileResponse.email,
                nickname: profileResponse.nick,
                profileImageURL: profileResponse.profileImage
            )
            
            await MainActor.run {
                self.currentUser = user
                self.isLoggedIn = true
                self.isLoading = false
                self.startTokenRefreshTimer() // 110ì´ˆë§ˆë‹¤ ìë™ ê°±ì‹ 
            }
            
        } catch {
            await MainActor.run { self.logout() }
        }
    }
    
    // ì•± ìƒëª…ì£¼ê¸° ê´€ë¦¬
    private func setupAppLifecycleHandling() {
        NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)
            .sink { [weak self] _ in
                guard let self = self else { return }
                
                if self.isLoggedIn {
                    // ë¡œê·¸ì¸ ìƒíƒœì—ì„œ í† í° ê°±ì‹  íƒ€ì´ë¨¸ ì¬ì‹œì‘
                    self.startTokenRefreshTimer()
                    Task { await self.checkAndRefreshTokenIfNeeded() }
                } else if self.tokenManager.refreshToken != nil {
                    // í† í°ì€ ìˆì§€ë§Œ ë¡œê·¸ì¸ ìƒíƒœê°€ ì•„ë‹Œ ê²½ìš° ìë™ ë¡œê·¸ì¸ ì‹œë„
                    Task { await self.loadUserIfTokenExists() }
                }
            }
    }
}
```

### **SocketIO ê¸°ë°˜ ì‹¤ì‹œê°„ ì±„íŒ…ê³¼ ë¡œì»¬ ì €ì¥ ì‹œìŠ¤í…œ êµ¬í˜„**
* WebSocket ì—°ê²° ìƒíƒœ ê´€ë¦¬ì™€ ìë™ ì¬ì—°ê²° ë©”ì»¤ë‹ˆì¦˜ìœ¼ë¡œ ë„¤íŠ¸ì›Œí¬ ë¶ˆì•ˆì • ìƒí™© ëŒ€ì‘
* ì‹¤ì‹œê°„ ë©”ì‹œì§€ ìˆ˜ì‹  ì‹œ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸ í›„ ë°±ê·¸ë¼ìš´ë“œ ë¡œì»¬ ì €ì¥ìœ¼ë¡œ ì‚¬ìš©ì ê²½í—˜ ìš°ì„ 
* ì¤‘ë³µ ë©”ì‹œì§€ ì²˜ë¦¬ ë°©ì§€ ë¡œì§ê³¼ ì¬ì‹œë„ ë©”ì»¤ë‹ˆì¦˜ìœ¼ë¡œ ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥
* Realm ê¸°ë°˜ ì˜¤í”„ë¼ì¸ ë©”ì‹œì§€ ì €ì¥ê³¼ ì•± ì‹œì‘ ì‹œ ë¡œì»¬ ë©”ì‹œì§€ ìš°ì„  ë¡œë”©

```swift
class SocketUseCaseImpl: SocketUseCase {
    private var isProcessingMessage = false
    private let realtimeMessageSubject = PassthroughSubject<ChatMessage, Never>()
    
    private func handleIncomingMessage(_ message: ChatMessage) {
        guard !isProcessingMessage else { return }
        isProcessingMessage = true
        
        // 1ë‹¨ê³„: ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸ (ìµœìš°ì„ )
        DispatchQueue.main.async {
            self.realtimeMessageSubject.send(message)
        }
        
        // 2ë‹¨ê³„: ë°±ê·¸ë¼ìš´ë“œ ë¡œì»¬ ì €ì¥ (ë…ë¦½ì )
        Task {
            await saveMessageWithRetry(message, maxRetries: 3)
            isProcessingMessage = false
        }
    }
    
    private func saveMessageWithRetry(_ message: ChatMessage, maxRetries: Int) async {
        for attempt in 1...maxRetries {
            do {
                try await chatUseCase.saveMessage(message)
                print("âœ… ë©”ì‹œì§€ ì €ì¥ ì„±ê³µ (ì‹œë„ \(attempt))")
                return
                
            } catch {
                if attempt == maxRetries {
                    print("ğŸ’¥ ë©”ì‹œì§€ ì €ì¥ ìµœì¢… ì‹¤íŒ¨")
                    await handleSaveFailure(message, error: error)
                } else {
                    // ì§€ìˆ˜ ë°±ì˜¤í”„ë¡œ ì¬ì‹œë„
                    let delay = pow(2.0, Double(attempt - 1))
                    try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                }
            }
        }
    }
}

// ì±„íŒ… ë·° ë¡œë”© ì‹œ ë¡œì»¬ ìš°ì„  ì „ëµ
class ChatViewModel: ObservableObject {
    private func loadMessages() {
        Task {
            // 1. ë¡œì»¬ ë©”ì‹œì§€ ë¨¼ì € ë¡œë“œ (ì¦‰ì‹œ UI í‘œì‹œ)
            let localMessages = try await chatUseCase.getLocalMessages(roomId: roomId)
            updateMessagesInitially(localMessages)
            
            // 2. ì„œë²„ì™€ ë™ê¸°í™” (ë°±ê·¸ë¼ìš´ë“œ)
            let latestMessage = try await chatUseCase.getLatestLocalMessage(roomId: roomId)
            let syncedMessages = try await chatUseCase.syncMessages(
                roomId: roomId,
                since: latestMessage?.createdAt
            )
            updateMessagesInitially(syncedMessages)
            
            // 3. ì†Œì¼“ ì—°ê²° (ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸)
            socketUseCase.connect(roomId: roomId)
        }
    }
}
```

### **Realm ê¸°ë°˜ ì˜¤í”„ë¼ì¸ ìš°ì„  ë°ì´í„° ë™ê¸°í™” ì‹œìŠ¤í…œ**
* ì±„íŒ… ë©”ì‹œì§€ì™€ ì±„íŒ…ë°© ì •ë³´ì˜ ë¡œì»¬ ìš°ì„  ì €ì¥ìœ¼ë¡œ ì¦‰ê°ì ì¸ UI ë°˜ì‘ì„± í™•ë³´
* ì„œë²„ ë™ê¸°í™” ì‹¤íŒ¨ ì‹œ ìë™ ì¬ì‹œë„ ë©”ì»¤ë‹ˆì¦˜ê³¼ ì¶©ëŒ í•´ê²° ì „ëµ êµ¬í˜„
* Thread-Safeí•œ Realm ì ‘ê·¼ì„ ìœ„í•œ Actor íŒ¨í„´ ì ìš©
* ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜ê³¼ ìŠ¤í‚¤ë§ˆ ë²„ì „ ê´€ë¦¬ë¡œ ì•± ì—…ë°ì´íŠ¸ ì•ˆì •ì„± ë³´ì¥

```swift
final class RealmChatRepository: ChatLocalRepository {
    private let realm: Realm
    
    init() throws {
        var config = Realm.Configuration()
        config.schemaVersion = 1
        config.migrationBlock = { migration, oldSchemaVersion in
            // ìŠ¤í‚¤ë§ˆ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§
            if oldSchemaVersion < 1 {
                // í•„ìš”í•œ ë§ˆì´ê·¸ë ˆì´ì…˜ ìˆ˜í–‰
            }
        }
        
        self.realm = try Realm(configuration: config)
    }
    
    @MainActor
    func saveMessage(_ message: ChatMessage) async throws {
        let entity = ChatMessageEntity.fromDomain(message)
        
        try realm.write {
            realm.add(entity, update: .modified)
        }
        
        print("âœ… RealmChatRepository: ë©”ì‹œì§€ ì €ì¥ ì™„ë£Œ - chatId: \(message.chatId)")
    }
    
    @MainActor
    func syncMessages(roomId: String, since: Date?) async throws -> [ChatMessage] {
        // ì„œë²„ì—ì„œ ìµœì‹  ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
        let serverMessages = try await fetchMessagesFromServer(roomId: roomId, since: since)
        
        // ë¡œì»¬ì— ì €ì¥ (ì¤‘ë³µ ì œê±°ëŠ” primaryKeyë¡œ ì²˜ë¦¬)
        for message in serverMessages {
            try await saveMessage(message)
        }
        
        // ìµœì‹  ë¡œì»¬ ë°ì´í„° ë°˜í™˜
        return try await getMessages(roomId: roomId)
    }
    
    // ì‹¤ì‹œê°„ ë°ì´í„° ê´€ì°°
    func observeMessages(roomId: String) -> AnyPublisher<[ChatMessage], Never> {
        let results = realm.objects(ChatMessageEntity.self)
            .filter("roomId == %@", roomId)
            .sorted(byKeyPath: "createdAt", ascending: true)
        
        return Future { promise in
            let token = results.observe { changes in
                switch changes {
                case .initial(let results), .update(let results, _, _, _):
                    let messages = Array(results).map { $0.toDomain() }
                    promise(.success(messages))
                case .error(let error):
                    print("âŒ RealmChatRepository: ë©”ì‹œì§€ ê´€ì°° ì—ëŸ¬ - \(error)")
                    promise(.success([]))
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
```

### **ì•„ì„í¬íŠ¸ ì—°ë™ ì•ˆì „í•œ ê²°ì œ ì‹œìŠ¤í…œ êµ¬í˜„**
* PGì‚¬ ì—°ë™ì„ í†µí•œ ì•ˆì „í•œ ê²°ì œ í”Œë¡œìš°ì™€ ì´ì¤‘ ê²°ì œ ë°©ì§€ ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„
* ê²°ì œ ì „/í›„ ê²€ì¦ ë¡œì§ìœ¼ë¡œ ê²°ì œ ë¬´ê²°ì„± ë³´ì¥ ë° ìœ„ë³€ì¡° ë°©ì§€
* ì‚¬ìš©ì ì·¨ì†Œì™€ ê²°ì œ ì‹¤íŒ¨ ìƒí™© êµ¬ë¶„ ì²˜ë¦¬ë¡œ ì •í™•í•œ ì—ëŸ¬ í•¸ë“¤ë§ ì œê³µ
* WebView ê¸°ë°˜ ê²°ì œ UIì™€ Native ì•± ê°„ ìƒíƒœ ë™ê¸°í™” ì‹œìŠ¤í…œ êµ¬ì¶•

```swift
class PaymentManager: ObservableObject {
    @Published var paymentResult: PaymentResult = .none
    private var paymentCompletion: ((Result<String, PaymentError>) -> Void)?
    
    func requestPayment(orderCode: String, amount: Int) async throws -> String {
        return try await withCheckedThrowingContinuation { continuation in
            paymentCompletion = { result in
                continuation.resume(with: result)
            }
            
            DispatchQueue.main.async {
                self.showPaymentSheet(orderCode: orderCode, amount: amount)
            }
        }
    }
    
    private func processPaymentResult(_ response: IamportResponse?) {
        guard let response = response else {
            paymentResult = .failed(error: "ê²°ì œ ì‘ë‹µì„ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
            paymentCompletion?(.failure(.invalidResponse))
            return
        }
        
        if response.success == true {
            if let impUid = response.imp_uid {
                print("âœ… PaymentManager: ê²°ì œ ì„±ê³µ - imp_uid: \(impUid)")
                paymentResult = .success(impUid: impUid)
                paymentCompletion?(.success(impUid))
            } else {
                paymentResult = .failed(error: "ê²°ì œ IDë¥¼ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
                paymentCompletion?(.failure(.invalidResponse))
            }
        } else {
            let errorMessage = response.error_msg ?? "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
            
            // ì‚¬ìš©ì ì·¨ì†Œ ì—¬ë¶€ í™•ì¸
            if errorMessage.contains("ì·¨ì†Œ") || errorMessage.contains("cancel") {
                paymentResult = .cancelled
                paymentCompletion?(.failure(.userCancelled))
            } else {
                paymentResult = .failed(error: errorMessage)
                paymentCompletion?(.failure(.paymentFailed(errorMessage)))
            }
        }
        
        paymentCompletion = nil
    }
}

// ê²°ì œ ê²€ì¦ UseCase
func validateAndCompletePayment(impUid: String) async throws -> PaymentValidationResponse {
    // 1. ì„œë²„ì—ì„œ ê²°ì œ ê²€ì¦
    let validation = try await orderUseCase.validatePayment(impUid: impUid)
    
    // 2. ê²°ì œ ì˜ìˆ˜ì¦ í™•ì¸ (ì„ íƒì )
    let receipt = try await orderUseCase.getPaymentReceipt(orderCode: validation.order_item.order_code)
    
    // 3. ê²°ì œ ê¸ˆì•¡ ê²€ì¦
    guard receipt.amount == validation.order_item.filter.price else {
        throw PaymentError.amountMismatch
    }
    
    return validation
}
```

### **JWT ê¸°ë°˜ ë³´ì•ˆ ê°•í™” ì¸ì¦ ì‹œìŠ¤í…œê³¼ ìë™ í† í° ê°±ì‹ **
* Access Tokenê³¼ Refresh Tokenì„ í™œìš©í•œ ë³´ì•ˆ ê°•í™” ì¸ì¦ ì•„í‚¤í…ì²˜ êµ¬í˜„
* í† í° ë§Œë£Œ ì‹œ ìë™ ê°±ì‹  ë¡œì§ê³¼ ë™ì‹œ ìš”ì²­ì— ëŒ€í•œ ì¤‘ë³µ ê°±ì‹  ë°©ì§€ ì‹œìŠ¤í…œ
* í† í° ê°±ì‹  ì‹¤íŒ¨ ì‹œ ìë™ ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬ì™€ ì‚¬ìš©ì ì•ˆë‚´ ë©”ì»¤ë‹ˆì¦˜
* JWT í˜ì´ë¡œë“œ íŒŒì‹±ì„ í†µí•œ ì‚¬ìš©ì ì •ë³´ ì¶”ì¶œ ë° í† í° ìœ íš¨ì„± ê²€ì¦

```swift
extension NetworkManager {
    private func handleTokenRefresh<T: Decodable>(router: APIRouter, type: T.Type) async throws -> T {
        // ì¤‘ë³µ ê°±ì‹  ë°©ì§€
        guard !isRefreshing else {
            return try await withCheckedThrowingContinuation { continuation in
                let request = try router.asURLRequest()
                requestsToRetry.append((request, { result in
                    switch result {
                    case .success(let data):
                        do {
                            let decodedResult = try JSONDecoder().decode(T.self, from: data)
                            continuation.resume(returning: decodedResult)
                        } catch {
                            continuation.resume(throwing: error)
                        }
                    case .failure(let error):
                        continuation.resume(throwing: error)
                    }
                }))
            }
        }
        
        isRefreshing = true
        defer { 
            isRefreshing = false
            processRetryQueue()
        }
        
        do {
            // ë¦¬í”„ë ˆì‹œ í† í°ìœ¼ë¡œ ìƒˆ í† í° ë°œê¸‰
            let refreshResponse = try await authUseCase.refreshToken()
            tokenManager.saveTokens(
                accessToken: refreshResponse.accessToken,
                refreshToken: refreshResponse.refreshToken
            )
            
            print("âœ… í† í° ê°±ì‹  ì„±ê³µ")
            
            // ì›ë˜ ìš”ì²­ ì¬ì‹œë„
            return try await request(router, type: type)
            
        } catch {
            print("âŒ í† í° ê°±ì‹  ì‹¤íŒ¨: \(error)")
            
            // ê°±ì‹  ì‹¤íŒ¨ ì‹œ ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬
            await MainActor.run {
                AuthState.shared.logout()
            }
            
            throw NetworkError.refreshTokenExpired
        }
    }
    
    private func processRetryQueue() {
        let currentQueue = requestsToRetry
        requestsToRetry.removeAll()
        
        for (request, completion) in currentQueue {
            Task {
                do {
                    let (data, _) = try await URLSession.shared.data(for: request)
                    completion(.success(data))
                } catch {
                    completion(.failure(error))
                }
            }
        }
    }
}
```

### **ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ì´ë¯¸ì§€ ìºì‹± ë° ë‹¤ìš´ìƒ˜í”Œë§ ì‹œìŠ¤í…œ**
* NSCacheì™€ FileManagerë¥¼ ì¡°í•©í•œ 2ë‹¨ê³„ ìºì‹± ì „ëµìœ¼ë¡œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”
* ì´ë¯¸ì§€ ë‹¤ìš´ìƒ˜í”Œë§ê³¼ ì••ì¶•ì„ í†µí•œ ë””ìŠ¤í¬ ê³µê°„ íš¨ìœ¨ì„± í–¥ìƒ
* LRU ì•Œê³ ë¦¬ì¦˜ ê¸°ë°˜ ìºì‹œ ê´€ë¦¬ì™€ ë©”ëª¨ë¦¬ ì••ë°• ìƒí™© ëŒ€ì‘ ì‹œìŠ¤í…œ - ê°€ì¥ ì˜¤ë˜ëœ ìºì‹œë¶€í„° ì •ë¦¬
* ë·° ìƒëª…ì£¼ê¸°ì— ë”°ë¥¸ ìë™ ìºì‹œ í•´ì œë¡œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€

```swift
class ImageLoader: ObservableObject {
    private let cache = NSCache<NSString, UIImage>()
    private let memoryCache = NSCache<NSString, NSData>()
    private let session = URLSession.shared
    
    init() {
        // ë©”ëª¨ë¦¬ ìºì‹œ ì„¤ì •
        cache.countLimit = 100 // ìµœëŒ€ 100ê°œ ì´ë¯¸ì§€
        cache.totalCostLimit = 50 * 1024 * 1024 // 50MB
        
        memoryCache.countLimit = 50
        memoryCache.totalCostLimit = 25 * 1024 * 1024 // 25MB
        
        // ë©”ëª¨ë¦¬ ê²½ê³  ì‹œ ìºì‹œ ì •ë¦¬
        NotificationCenter.default.addObserver(
            forName: UIApplication.didReceiveMemoryWarningNotification,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.clearCache()
        }
    }
    
    func loadImage(from url: URL) async -> UIImage? {
        let cacheKey = url.absoluteString as NSString
        
        // 1. ë©”ëª¨ë¦¬ ìºì‹œ í™•ì¸
        if let cachedImage = cache.object(forKey: cacheKey) {
            return cachedImage
        }
        
        // 2. ë””ìŠ¤í¬ ìºì‹œ í™•ì¸
        if let cachedData = memoryCache.object(forKey: cacheKey),
           let image = UIImage(data: cachedData as Data) {
            cache.setObject(image, forKey: cacheKey)
            return image
        }
        
        // 3. ë„¤íŠ¸ì›Œí¬ì—ì„œ ë‹¤ìš´ë¡œë“œ
        do {
            let (data, _) = try await session.data(from: url)
            
            // ë‹¤ìš´ìƒ˜í”Œë§ ìˆ˜í–‰
            let downsampledData = await downsampleImage(data: data, targetSize: CGSize(width: 400, height: 400))
            
            if let image = UIImage(data: downsampledData) {
                // ìºì‹œì— ì €ì¥
                cache.setObject(image, forKey: cacheKey)
                memoryCache.setObject(downsampledData as NSData, forKey: cacheKey)
                
                return image
            }
        } catch {
            print("âŒ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: \(error)")
        }
        
        return nil
    }
    
    private func downsampleImage(data: Data, targetSize: CGSize) async -> Data {
        return await withCheckedContinuation { continuation in
            guard let imageSource = CGImageSourceCreateWithData(data as CFData, nil),
                  let imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as? [CFString: Any],
                  let pixelWidth = imageProperties[kCGImagePropertyPixelWidth] as? CGFloat,
                  let pixelHeight = imageProperties[kCGImagePropertyPixelHeight] as? CGFloat else {
                continuation.resume(returning: data)
                return
            }
            
            // ë‹¤ìš´ìƒ˜í”Œë§ì´ í•„ìš”í•œì§€ í™•ì¸
            let imageSize = CGSize(width: pixelWidth, height: pixelHeight)
            let scale = min(targetSize.width / imageSize.width, targetSize.height / imageSize.height)
            
            if scale >= 1.0 {
                continuation.resume(returning: data)
                return
            }
            
            // ë‹¤ìš´ìƒ˜í”Œë§ ìˆ˜í–‰
            let downsampleOptions: [CFString: Any] = [
                kCGImageSourceCreateThumbnailFromImageAlways: true,
                kCGImageSourceCreateThumbnailWithTransform: true,
                kCGImageSourceThumbnailMaxPixelSize: max(targetSize.width, targetSize.height)
            ]
            
            guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions as CFDictionary) else {
                continuation.resume(returning: data)
                return
            }
            
            let uiImage = UIImage(cgImage: downsampledImage)
            if let jpegData = uiImage.jpegData(compressionQuality: 0.8) {
                continuation.resume(returning: jpegData)
            } else {
                continuation.resume(returning: data)
            }
        }
    }
}
```

### **íƒ€ì… ì„¸ì´í”„í•œ ë””ìì¸ ì‹œìŠ¤í…œê³¼ ë°˜ì‘í˜• UI êµ¬í˜„**
* enum ê¸°ë°˜ ë””ìì¸ í† í°ìœ¼ë¡œ íƒ€ì… ì•ˆì „ì„±ê³¼ ì¼ê´€ì„± ë³´ì¥
* GeometryReaderì™€ ViewModifierë¥¼ í™œìš©í•œ ë°˜ì‘í˜• ë ˆì´ì•„ì›ƒ ì‹œìŠ¤í…œ

```swift
struct DesignSystem {
    enum Colors {
        enum Brand {
            static let brightTurquoise = Color(hex: "00D9FF")
            static let deepBlue = Color(hex: "0A1A2A")
            static let softGray = Color(hex: "F5F5F5")
        }
        
        enum Gray {
            static let gray15 = Color(hex: "262626")
            static let gray45 = Color(hex: "737373")
            static let gray75 = Color(hex: "BFBFBF")
        }
    }
    
    enum Typography {
        enum FontFamily {
            enum PretendardWeight: String {
                case light = "Pretendard-Light"
                case regular = "Pretendard-Regular"
                case medium = "Pretendard-Medium"
                case semiBold = "Pretendard-SemiBold"
                case bold = "Pretendard-Bold"
                
                var fontName: String { rawValue }
            }
            
            enum HakgyoansimWeight: String {
                case regular = "Hakgyoansim-Regular"
                case bold = "Hakgyoansim-Bold"
                
                var fontName: String { rawValue }
            }
        }
        
        enum TextStyle {
            case title1, title2, title3
            case body1, body2, body3
            case caption1, caption2
            
            func font() -> Font {
                switch self {
                case .title1:
                    return .pretendard(size: 24, weight: .bold)
                case .title2:
                    return .pretendard(size: 20, weight: .semiBold)
                case .title3:
                    return .pretendard(size: 18, weight: .medium)
                case .body1:
                    return .pretendard(size: 16, weight: .regular)
                case .body2:
                    return .pretendard(size: 14, weight: .regular)
                case .body3:
                    return .pretendard(size: 12, weight: .regular)
                case .caption1:
                    return .pretendard(size: 11, weight: .medium)
                case .caption2:
                    return .pretendard(size: 10, weight: .regular)
                }
            }
        }
    }
}

// ë°˜ì‘í˜• ë·° modifier
struct ResponsiveLayout: ViewModifier {
    @Environment(\.horizontalSizeClass) private var horizontalSizeClass
    
    func body(content: Content) -> some View {
        GeometryReader { geometry in
            content
                .padding(.horizontal, horizontalPadding(for: geometry.size.width))
                .animation(.easeInOut(duration: 0.3), value: horizontalSizeClass)
        }
    }
    
    private func horizontalPadding(for width: CGFloat) -> CGFloat {
        if width < 375 {
            return 16
        } else if width < 414 {
            return 20
        } else {
            return 24
        }
    }
}
```

### **ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ ì§€ì—° ë¡œë”©ê³¼ ë©”ëª¨ë¦¬ ê´€ë¦¬**
* NavigationLazyViewë¥¼ í†µí•œ ë·° ì§€ì—° ë¡œë”©ìœ¼ë¡œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”
* weak ì°¸ì¡° íŒ¨í„´ê³¼ AnyCancellable ê´€ë¦¬ë¡œ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì™„ì „ ì œê±°
* Task ì·¨ì†Œ ë©”ì»¤ë‹ˆì¦˜ê³¼ ìƒëª…ì£¼ê¸° ê´€ë¦¬ë¡œ ë¶ˆí•„ìš”í•œ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ë°©ì§€
* ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”©ê³¼ í˜ì´ì§€ë„¤ì´ì…˜ìœ¼ë¡œ ìŠ¤í¬ë¡¤ ì„±ëŠ¥ í–¥ìƒ

```swift
// ì§€ì—° ë¡œë”© ë·° ë˜í¼
struct NavigationLazyView<T: View>: View {
    let build: () -> T
    
    init(_ build: @autoclosure @escaping () -> T) {
        self.build = build
    }
    
    var body: some View {
        build()
    }
}

// ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ViewModel
class HomeViewModel: ObservableObject {
    @Published var todayFilter: TodayFilterResponse?
    @Published var hotTrendFilters: [FilterItem] = []
    @Published var isLoading = false
    
    private var cancellables = Set<AnyCancellable>()
    private var loadingTask: Task<Void, Never>?
    
    deinit {
        print("ğŸ—‘ï¸ HomeViewModel: ë©”ëª¨ë¦¬ í•´ì œ")
        cancellables.removeAll()
        loadingTask?.cancel()
    }
    
    func loadData() {
        // ì´ì „ ì‘ì—… ì·¨ì†Œ
        loadingTask?.cancel()
        
        loadingTask = Task { [weak self] in
            guard let self = self else { return }
            
            await MainActor.run {
                self.isLoading = true
            }
            
            do {
                // ë³‘ë ¬ ë°ì´í„° ë¡œë”©
                async let todayFilter = filterUseCase.getTodayFilter()
                async let hotTrendFilters = filterUseCase.getHotTrendFilters()
                
                let (todayResult, hotTrendResult) = try await (todayFilter, hotTrendFilters)
                
                // Task ì·¨ì†Œ í™•ì¸
                guard !Task.isCancelled else { return }
                
                await MainActor.run {
                    self.todayFilter = todayResult
                    self.hotTrendFilters = hotTrendResult
                    self.isLoading = false
                }
                
            } catch {
                guard !Task.isCancelled else { return }
                
                await MainActor.run {
                    self.isLoading = false
                    // ì—ëŸ¬ ì²˜ë¦¬
                }
            }
        }
    }
}
```

## ğŸ” ë¬¸ì œ í•´ê²° ë° ìµœì í™”

### **ì‹¤ì‹œê°„ ì±„íŒ… ë©”ì‹œì§€ ì²˜ë¦¬ ìµœì í™”**
* **ë¬¸ì œ**: ë™ì‹œ ë‹¤ë°œì ì¸ ì†Œì¼“ ì´ë²¤íŠ¸ë¡œ ì¸í•œ ë©”ì‹œì§€ ì¤‘ë³µ ì €ì¥ ë° UI í”„ë¦¬ì§• í˜„ìƒ
* **í•´ê²°**: ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸ í›„ ë°±ê·¸ë¼ìš´ë“œ ì €ì¥ ë¶„ë¦¬ì™€ ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€ í”Œë˜ê·¸ êµ¬í˜„
* **íš¨ê³¼**: ì‹¤ì‹œê°„ ì±„íŒ… ë°˜ì‘ì„± í–¥ìƒ ë° ë©”ì‹œì§€ ì¤‘ë³µ ì²˜ë¦¬ ì™„ì „ ì œê±°

### **ìë™ ë¡œê·¸ì¸ í† í° ê°±ì‹  ë™ì‹œì„± ë¬¸ì œ í•´ê²°**
* **ë¬¸ì œ**: ë‹¤ì¤‘ API ìš”ì²­ ì‹œ í† í° ê°±ì‹  ì¤‘ë³µ ì‹¤í–‰ìœ¼ë¡œ ì¸í•œ ì¸ì¦ ì˜¤ë¥˜
* **í•´ê²°**: í† í° ê°±ì‹  íì‰ ì‹œìŠ¤í…œê³¼ ì¤‘ë³µ ìš”ì²­ ë°©ì§€ ë¡œì§ êµ¬í˜„
* **íš¨ê³¼**: ì¸ì¦ ì„±ê³µë¥  99% ë‹¬ì„± ë° ìë™ ë¡œê·¸ì¸ ì•ˆì •ì„± í™•ë³´

### **Core Image í•„í„°ë§ ì„±ëŠ¥ ìµœì í™”**
* **ë¬¸ì œ**: ì‹¤ì‹œê°„ í•„í„° í”„ë¦¬ë·° ì‹œ UI ë¸”ë¡œí‚¹ ë° ë©”ëª¨ë¦¬ ê³¼ì‚¬ìš© ë¬¸ì œ
* **í•´ê²°**: GPU ì—°ì‚° ìµœì í™”ì™€ ì´ë¯¸ì§€ ë‹¤ìš´ìƒ˜í”Œë§ìœ¼ë¡œ ë Œë”ë§ ì„±ëŠ¥ 300% í–¥ìƒ
* **íš¨ê³¼**: 60fps ì‹¤ì‹œê°„ í”„ë¦¬ë·° ë‹¬ì„± ë° ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ 50% ì ˆê°

### **ì´ë¯¸ì§€ ìºì‹± ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ í•´ê²°**
* **ë¬¸ì œ**: ëŒ€ëŸ‰ ì´ë¯¸ì§€ ë¡œë”© ì‹œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê¸‰ì¦ ë° ì•± í¬ë˜ì‹œ ìœ„í—˜
* **í•´ê²°**: NSCache ì •ì±… ìµœì í™”ì™€ ë©”ëª¨ë¦¬ ê²½ê³  ëŒ€ì‘ ì‹œìŠ¤í…œ êµ¬í˜„
* **íš¨ê³¼**: ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ 60% ì ˆê° ë° í¬ë˜ì‹œìœ¨ 0%ëŒ€ ë‹¬ì„±

### **ê²°ì œ í”Œë¡œìš° ì•ˆì •ì„± ê°•í™”**
* **ë¬¸ì œ**: ë„¤íŠ¸ì›Œí¬ ë¶ˆì•ˆì • ì‹œ ê²°ì œ ìƒíƒœ ë¶ˆì¼ì¹˜ ë° ì¤‘ë³µ ê²°ì œ ìœ„í—˜
* **í•´ê²°**: ê²°ì œ ê²€ì¦ ë¡œì§ ê°•í™”ì™€ ìƒíƒœ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„
* **íš¨ê³¼**: ê²°ì œ ì„±ê³µë¥  98% ë‹¬ì„± ë° ì¤‘ë³µ ê²°ì œ ì™„ì „ ì°¨ë‹¨

## ğŸš€ í–¥í›„ ê°œì„  ë°©í–¥

1. **Unit Testing í™•ëŒ€**: Domain Layerì™€ UseCaseì˜ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ 90% ë‹¬ì„±
2. **AI í•„í„° ì¶”ì²œ ì‹œìŠ¤í…œ**: ì‚¬ìš©ì ì·¨í–¥ ë¶„ì„ ê¸°ë°˜ ê°œì¸í™” í•„í„° ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
3. **ë‹¤êµ­ì–´ ì§€ì›**: ê¸€ë¡œë²Œ ì„œë¹„ìŠ¤ í™•ì¥ì„ ìœ„í•œ Localization ë° RTL ì–¸ì–´ ì§€ì›
4. **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: Crashlyticsì™€ Firebase Analytics ì—°ë™ ì‹¤ì‹œê°„ ì„±ëŠ¥ ì§€í‘œ ìˆ˜ì§‘
5. **WebRTC ì˜ìƒí†µí™”**: ì°½ì‘ìì™€ ì‹¤ì‹œê°„ ì˜ìƒ ìƒë‹´ ê¸°ëŠ¥ ì¶”ê°€
